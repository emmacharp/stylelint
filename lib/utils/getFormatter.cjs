// NOTICE: This file is generated by Rollup. To modify it,
// please instead edit the ESM counterpart and rebuild with Rollup (npm run build).
'use strict';

const constants = require('../constants.cjs');
const index = require('../formatters/index.cjs');
const getConfigForFile = require('../getConfigForFile.cjs');
const getFormatterOptionsText = require('./getFormatterOptionsText.cjs');

/** @import {Formatter, FormatterType, InternalApi} from 'stylelint' */

/**
 * @param {InternalApi} stylelint
 * @param {Object} [params]
 * @param {FormatterType | Formatter | undefined} [params.formatterType]
 * @param {string} [params.filePath]
 * @returns {Promise<Formatter>}
 */
async function getFormatter(stylelint, params = {}) {
	const { formatterType, filePath } = params;
	const cwd = stylelint._options.cwd;
	const configPath = stylelint._options.configFile || filePath || cwd;
	let formatter = formatterType;

	if (!formatter) {
		const resolvedConfig = stylelint._options.config
			? stylelint._options
			: await getConfigForFile(stylelint, configPath, configPath);
		const configFormatter = resolvedConfig?.config.formatter;

		formatter = stylelint._options.formatter || configFormatter;
	}

	/** @type {Formatter} */

	if (typeof formatter === 'string') {
		const formatterFunction = index[formatter];

		if (formatterFunction === undefined) {
			const formattersText = getFormatterOptionsText(', ', '"');

			throw new Error(`You must use a valid formatter option: ${formattersText} or a function`);
		}

		return formatterFunction;
	}

	if (typeof formatter === 'function') {
		return Promise.resolve(formatter);
	}

	return index[constants.DEFAULT_FORMATTER];
}

module.exports = getFormatter;
